<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      padding: 0;
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <script type="module">
    import * as THREE from "https://unpkg.com/three/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js";
    import Stats from "https://unpkg.com/three/examples/jsm/libs/stats.module.js";
    import dat from "https://unpkg.com/three/examples/jsm/libs/dat.gui.module.js";

    "use strict";

    class Quad extends THREE.Mesh {
      constructor() {
        super()
        let vertices = [-0.5, 0.5, 0,
        -0.5, -0.5, 0,
          0.5, -0.5, 0,
          0.5, 0.5, 0]
        let index = [0, 1, 2,
          0, 2, 3]
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.geometry.setIndex(index);
        this.material = new THREE.MeshBasicMaterial({ color: "black", wireframe: true });
        this.name = "Quad"
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    class Triangle extends THREE.Mesh {
      constructor() {
        super()
        let vertices = [-0.5, 0.5, 0,
        -0.5, -0.5, 0,
          0.5, -0.5, 0]
        let index = [0, 1, 2]
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.geometry.setIndex(index);
        this.material = new THREE.MeshBasicMaterial({ color: "black", wireframe: true });
        this.name = "Triangle"
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    class Box extends THREE.Group {
      constructor() {
        super();
        this.faces = [new Quad(), new Quad(), new Quad(), new Quad(), new Quad(), new Quad()]
        this.faces[0].position.z = 0.5;
        this.faces[1].position.z = -0.5;
        this.faces[1].rotation.y = Math.PI
        this.faces[2].rotation.y = Math.PI / 2
        this.faces[2].position.x = 0.5
        this.faces[3].rotation.y = Math.PI / 2 * 3
        this.faces[3].position.x = -0.5
        this.faces[4].rotation.x = Math.PI / 2 * 3
        this.faces[4].position.y = 0.5
        this.faces[5].rotation.x = Math.PI / 2
        this.faces[5].position.y = -0.5
        this.faces.forEach(face => { this.add(face) })
        this.name = "Box"
      }
      setWireframe(val) {
        this.faces.forEach(face => face.setWireframe(val))
      }
    }

    class Pyramid extends THREE.Mesh {
      constructor() {
        super();
        let vertices = [0.5, 0, 0.5,
          -0.5, 0, 0.5,
          -0.5, 0, -0.5,
          0.5, 0, -0.5,
          0, 1, 0,
        ]
        let index = [0, 1, 2,
          0, 2, 3,
          0, 3, 4,
          0, 4, 1,
          1, 4, 2,
          2, 4, 3
        ]
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.geometry.setIndex(index);
        this.material = new THREE.MeshBasicMaterial({ color: "black", wireframe: true });
        this.name = "Pyramid"
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    
    class Dodecahedron extends THREE.Group {
      constructor() {
        super();
        let phi = (1+ Math.sqrt(5) )/2;
        let iphi = 1 / phi;
        this.vertices = [   1,   1,   1, 
                           1,   1,  -1,
                           1,  -1,   1,
                           1,  -1,  -1,
                          -1,   1,   1,
                          -1,   1,  -1,
                          -1,  -1,   1,
                          -1,  -1,  -1,
                          0,    phi,   iphi,
                          0,    phi,  -iphi,
                          0,   -phi,   iphi,
                          0,   -phi,  -iphi,
                          iphi,   0,   phi,
                          iphi,   0,  -phi,
                          -iphi,  0,   phi,
                          -iphi,  0,  -phi,
                           phi, iphi,    0,
                           phi, -iphi,   0,
                          -phi, iphi,    0,
                          -phi, -iphi,   0,
                          
        ]
        this.indexes = [
                    [14, 6, 10,
                    14, 10, 2,
                    14, 2, 12],

                    [14, 12, 0,
                    14, 0, 8,
                    14, 8, 4],

                    [14, 4, 18,
                    14, 18, 19,
                    14, 19, 6],

                    [12, 2, 17,
                    12, 17, 16,
                    12, 16, 0],

                    [0, 16, 1,
                    0, 1, 9,
                    0, 9, 8],

                    [8, 9, 5,
                    8, 5, 18,
                    8, 18, 4],

                    [9, 1, 13,
                    9, 13, 15,
                    9, 15, 5],

                    [1, 16, 17,
                    1, 17, 3,
                    1, 3, 13],

                    [18, 5, 15,
                    18, 15, 7,
                    18, 7, 19],

                    [6, 19, 7,
                    6, 7, 11,
                    6, 11, 10],

                    [7, 15, 13,
                    7, 13, 3,
                    7, 3, 11],

                    [2, 10, 11,
                    2, 11, 3,
                    2, 3, 17]
                  ];
        this.iColors = [[1,0,0],[0,1,0],[0,0,1],[0,1,1],[1,1,0],[1,0,1],[0.9,0.9,0.9],[0.5, 0.5, 0.5],[1, 0.5, 0],[0.5, 0, 1],[1, 0.5, 0.5],[0.5, 0.5, 1] ];
        this.colors =[];
        this.materials =[];
        this.geometries =[];
        this.faces =[];
        for(let i=0 ;i < this.iColors.length; i++ ){
          this.colors.push( new THREE.Color(this.iColors[i][0], this.iColors[i][1], this.iColors[i][2]));
          this.materials.push(new THREE.MeshBasicMaterial({color : this.colors[i], wireframe : true}));
          this.geometries.push( new THREE.BufferGeometry() );
          this.geometries[i].setAttribute("position", new THREE.Float32BufferAttribute(this.vertices, 3));
          this.geometries[i].setIndex(this.indexes[i]);
          this.faces.push(new THREE.Mesh( this.geometries[i], this.materials[i]));
          this.add(this.faces[i]);
        }
        

        
        
        
        this.name = "Dodecahedron"
      }
      setWireframe(val) {
        this.materials.forEach(m => m.wireframe = val);
      }
    }

    class House extends THREE.Group {
      constructor() {
        super();
        this.base = new Box();
        this.roof = new Pyramid();
        this.roof.position.y += 0.5
        this.add(this.base)
        this.add(this.roof)
        this.name = "House"
      }
      setWireframe(val) {
        this.base.setWireframe(val);
        this.roof.setWireframe(val);
      }
    }

    class Circle extends THREE.Mesh {
      constructor(radius = 1, radialSegments = 8) {
        super()
        let vertices = [0, 0, 0]
        let angle = 0;
        while ((2 * Math.PI) / angle > 1.0000000001) {
          let x = radius * Math.cos(angle)
          let y = radius * Math.sin(angle)
          vertices.push(x, y, 0)
          angle += (2 * Math.PI) / radialSegments
        }
        let index = []
        for (let i = 1; i < radialSegments; i++) {
          index.push(0, i, i + 1)
        }
        index.push(0, radialSegments, 1)
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.geometry.setIndex(index);
        this.material = new THREE.MeshBasicMaterial({ color: "black", wireframe: true });
        this.name = "Circle"
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    class Cylinder extends THREE.Mesh {
      constructor(height = 1, radius = 1, radialSegments = 8) {
        super()
        let vertices = [0, -height / 2, 0]
        let angle = 0;
        let i = 1;
        while ((2 * Math.PI) / angle > 1.0000000001) {
          let x = radius * Math.cos(angle)
          let y = radius * Math.sin(angle)
          vertices.push(x, -height / 2, y)
          angle += (2 * Math.PI) / radialSegments
        }
        angle = 0;
        vertices.push(0, height / 2, 0)
        i++
        while ((2 * Math.PI) / angle > 1.0000000001) {
          let x = radius * Math.cos(angle)
          let y = radius * Math.sin(angle)
          vertices.push(x, height / 2, y)
          angle += (2 * Math.PI) / radialSegments
        }
        let index = []
        for (let i = 1; i < radialSegments; i++) {
          index.push(0, i, i + 1)
        }
        index.push(0, radialSegments, 1)
        for (let i = radialSegments + 1; i <= 2 * radialSegments; i++) {
          index.push(radialSegments + 1, i + 1, i)
        }
        index.push(radialSegments + 1, radialSegments + 2, radialSegments * 2 + 1)
        for (let i = 1; i < radialSegments; i++) {
          index.push(i, i + radialSegments + 1, i + radialSegments + 2)
          index.push(i, i + radialSegments + 2, i + 1)
        }
        index.push(radialSegments, radialSegments * 2 + 1, radialSegments + 2)
        index.push(radialSegments, radialSegments + 2, 1)
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.geometry.setIndex(index);
        this.material = new THREE.MeshBasicMaterial({ color: "black", wireframe: true });
        this.name = "Cylinder"
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    class Cone extends THREE.Mesh {
      constructor(height = 1, radius = 1, radialSegments = 8) {
        super()
        let vertices = [0, -height / 2, 0]
        let angle = 0;
        while ((2 * Math.PI) / angle > 1.0000000001) {
          let x = radius * Math.cos(angle)
          let y = radius * Math.sin(angle)
          vertices.push(x, -height / 2, y)
          angle += (2 * Math.PI) / radialSegments
        }
        vertices.push(0, height / 2, 0)
        let index = []
        for (let i = 1; i < radialSegments; i++) {
          index.push(0, i, i + 1)
          index.push(i, radialSegments + 1, i + 1)
        }
        index.push(0, radialSegments, 1)
        index.push(radialSegments, radialSegments + 1, 1)
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.geometry.setIndex(index);
        this.material = new THREE.MeshBasicMaterial({ color: "black", wireframe: true });
        this.name = "Cone"
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    class Pine extends THREE.Group {
      constructor() {
        super();
        this.base = new Cylinder(.3, .1625);
        this.top = new Cone(1, .5, 32);
        this.top.position.y += .65
        this.add(this.base)
        this.add(this.top)
        this.name = "Pine"
      }
      setWireframe(val) {
        this.base.setWireframe(val);
        this.top.setWireframe(val);
      }
    }

    class Octahedron extends THREE.Mesh {
      constructor(radius = 1) {
        super()
        let vertices = []
        let step = Math.PI / 2;
        for (let i = 0; i < 4; i++) {
          let x = radius * Math.cos(step * i)
          let y = radius * Math.sin(step * i)
          vertices.push(x, 0, y)
        }
        vertices.push(0, radius, 0)
        vertices.push(0, -radius, 0)
        let index = []
        for (let i = 0; i < 4; i++) {
          index.push(4, (i + 1) % 4, i)
          index.push(5, i, (i + 1) % 4)
        }
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.geometry.setIndex(index);
        this.material = new THREE.MeshBasicMaterial({ color: "black", wireframe: true });
        this.name = "Octahedron"
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    class Pikachu extends THREE.Mesh {
      constructor() {
        super()
        let vertices = [-5.539737701416016, -3.768954277038574, 1.0100507985555396e-08, -4.307949066162109, -3.812735080718994, 1.0100507985555396e-08, -1.4385390281677246, -1.2008659839630127, 0.0, -1.4385390281677246, -1.2008659839630127, 0.0, -4.038570404052734, -1.2143789529800415]
        this.geometry = new THREE.BufferGeometry();
        this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        this.material = new THREE.MeshBasicMaterial({ color: "yellow", wireframe: true });
        this.name = "Pikachu"
        this.geometry.scale(.03, .03, .03)
        this.geometry.rotateX(-Math.PI / 2)
      }
      setWireframe(val) {
        this.material.wireframe = val
      }
    }

    let renderer, scene, camera, cameraControls, stats;

    function init() {
      // RENDERER ENGINE
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor(new THREE.Color(1, 1, 1));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // SCENE
      scene = new THREE.Scene();

      // CAMERA
      let fov = 60;
      let aspect = window.innerWidth / window.innerHeight;
      let near = 0.1;
      let far = 100;
      camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 0, 3);
      cameraControls = new OrbitControls(camera, renderer.domElement);

      // SCENE GRAPH
      let allMeshes = [new Dodecahedron()]
      allMeshes.forEach(mesh => scene.add(mesh));

      // Floor
      const gridHelper = new THREE.GridHelper(10, 10);
      scene.add(gridHelper);

      // AXES
    scene.add( new THREE.AxesHelper( 20 ) );

      // STATS
      stats = new Stats();
      stats.showPanel(0); // 0: fps, 1:ms, 2:memory
      const statsDom = stats.dom;
      statsDom.setAttribute("id", "stats");
      document.body.appendChild(statsDom);

      // GUI
      const model = {
        wireframe: true,
        showStats: true,
        bgColor: 0x000,
        gridFloor: true,
      }
      const gui = new dat.GUI();
      const mainMenu = gui.addFolder("General Menu")
      mainMenu.add(model, "wireframe").setValue(true).name('Wireframe')
        .onChange(val => allMeshes.forEach(mesh => mesh.setWireframe(val)));
      mainMenu.add(model, "gridFloor").setValue(true).name('Grid floor')
        .onChange(val => {
          if (val) {
            scene.add(gridHelper);
          } else {
            scene.remove(gridHelper);
          }
        });
      mainMenu.add(model, "showStats").setValue(true).name('Show Stats')
        .onChange(val => {
          if (val) {
            statsDom.style.display = 'block'
          }
          else {
            statsDom.style.display = 'none'
          }
        });
      mainMenu.addColor(model, "bgColor").listen().name('Background Color').onChange(val => renderer.setClearColor(new THREE.Color(val)))

      const modelMenu = gui.addFolder("Models Menu")
      const params = {
    	posX: 0,
        posY: 0,
        posZ: 0,
        rot: 0
      }
      var x, y, z, rot;
      
      let sliderPosX = modelMenu.add(params, "posX").min(-5).max(5).step(0.5).setValue(0).name("Position X").listen().onChange(function(value) {
            x = value;    
      });
      let sliderPosY = modelMenu.add(params, "posY").min(-5).max(5).step(0.5).setValue(0).name("Position Y").listen().onChange(function(value) {
            y = value;   
      });
      let sliderPosZ = modelMenu.add(params, "posZ").min(-5).max(5).step(0.5).setValue(0).name("Position Z").listen().onChange(function(value) {
            z = value;    
      });
      let sliderRot = modelMenu.add(params, "rot").min(-180).max(180).step(10).setValue(0).name("Rotation ").listen().onChange(function(value) {
            rot = value * Math.PI / 180;
      });

      var quadObj = { Quad:function(){ 
          var a = new Quad()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
        }};
      modelMenu.add(quadObj,'Quad');

      var triangleObj = { Triangle:function(){ 
          var a = new Triangle();
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(triangleObj,'Triangle');

      var boxObj = { Box:function(){ 
          var a = new Box()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(boxObj,'Box');

      var pyramidObj = { Pyramid:function(){ 
          var a = new Pyramid()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(pyramidObj,'Pyramid');

      var houseObj = { House:function(){ 
          var a = new House()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(houseObj,'House');

      var circleObj = { Circle:function(){ 
          var a = new Circle()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(circleObj,'Circle');

      var cylinderObj = { Cylinder:function(){ 
          var a = new Cylinder()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(cylinderObj,'Cylinder');

      var coneObj = { Cone:function(){ 
          var a = new Cone()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(coneObj,'Cone');

      var pineObj = { Pine:function(){ 
          var a = new Pine()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(pineObj,'Pine');

      var octahedronObj = { Octahedron:function(){ 
          var a = new Octahedron()
          allMeshes.push(a)
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          scene.add(a)
         }};
      modelMenu.add(octahedronObj,'Octahedron');

      var pikachuObj = { Pikachu:function(){ 
          var a = new Pikachu()
          a.position.x = x
          a.position.y = y
          a.position.z = z
          a.rotation.y = rot
          allMeshes.push(a)
          scene.add(a)
         }};
      modelMenu.add(pikachuObj,'Pikachu');


      

      // ANIMATION
      renderLoop();
    }

    function renderLoop() {
      stats.begin();
      renderer.render(scene, camera); // DRAW SCENE
      stats.end();
      stats.update();
      requestAnimationFrame(renderLoop);
    }

    // EVENT LISTENERS & HANDLERS
    document.addEventListener("DOMContentLoaded", init);

    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

    })
  </script>
</body>

</html>